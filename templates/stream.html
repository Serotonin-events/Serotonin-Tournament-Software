<!-- templates/stream.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1920, height=1080">
    <title>Serotonin Tournament Software</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Condensed:wght@700&family=Inter:wght@400;600;700&family=MuseoModerno:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto Condensed', sans-serif;
            background-color: #1F2937; /* Dark Gray-800 Background */
            color: #F9FAFB; /* Gray-50 */
            overflow: hidden;
            height: 1080px;
            width: 1920px;
        }
        .bracket-title { font-family: 'MuseoModerno', sans-serif; }
        .round-title { font-family: 'Roboto Condensed', sans-serif; }
        .match-card {
            background-color: #374151; /* Gray-700 */
            border: 1px solid #4B5563; /* Gray-600 */
        }
        .player-row { background-color: #4B5563; }
        .player-row.winner { background-color: #10B981; color: #064E3B; } /* Emerald-500 */
        
        #connector-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }
    </style>
</head>
<body class="p-8 flex flex-col">

    <div id="main-container" class="relative flex-grow flex flex-col items-center gap-8">
        <!-- Bracket content will be rendered here -->
    </div>

    <script>
        const mainContainer = document.getElementById('main-container');
        
        function drawConnectors() {
            const canvas = document.getElementById('connector-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            const dpr = window.devicePixelRatio || 1;
            const rect = mainContainer.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#6B7280'; // Gray-500
            ctx.lineWidth = 2;

            const connectBrackets = (sourceSelector, destSelector) => {
                const sourceRounds = document.querySelectorAll(`${sourceSelector} .round-column`);
                if (sourceRounds.length === 0) return;

                // Connect rounds within a bracket
                for (let i = 0; i < sourceRounds.length - 1; i++) {
                    const currentRoundMatches = sourceRounds[i].querySelectorAll('.match-card');
                    const nextRoundMatches = sourceRounds[i+1].querySelectorAll('.match-card');
                    
                    currentRoundMatches.forEach((match, matchIndex) => {
                        const nextMatchIndex = Math.floor(matchIndex / 2);
                        if (nextMatchIndex < nextRoundMatches.length) {
                            connectElements(match, nextRoundMatches[nextMatchIndex]);
                        }
                    });
                }

                // Connect final round to the destination
                const finalRoundMatches = sourceRounds[sourceRounds.length - 1].querySelectorAll('.match-card');
                const destMatch = document.querySelector(`${destSelector} .match-card`);

                if (finalRoundMatches.length > 0 && destMatch) {
                    finalRoundMatches.forEach(match => connectElements(match, destMatch));
                }
            };
            
            connectBrackets('#upper-bracket-container', '#grand-final-container');
            connectBrackets('#lower-bracket-container', '#grand-final-container');
        }

        function connectElements(elem1, elem2) {
            if (!elem1 || !elem2) return;
            const rect1 = elem1.getBoundingClientRect();
            const rect2 = elem2.getBoundingClientRect();
            const containerRect = mainContainer.getBoundingClientRect();

            const startX = rect1.right - containerRect.left;
            const startY = rect1.top - containerRect.top + rect1.height / 2;
            const endX = rect2.left - containerRect.left;
            const endY = rect2.top - containerRect.top + rect2.height / 2;
            const midX = startX + (endX - startX) / 2;

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(midX, startY);
            ctx.lineTo(midX, endY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
        }

        function applyStreamStyles(colors) {
            document.body.style.color = colors.text || '#2b2b2b';
            document.body.style.backgroundColor = (colors.background === '#000000') ? '#1F2937' : colors.background;
        }

        function renderBracketView(state) {
            if (state.bracket_type === 'swiss') {
                renderSwissView(state);
            } else {
                renderDoubleElimView(state);
            }
        }

        function renderDoubleElimView(state) {
            applyStreamStyles(state.info.colors);
            const bracket = state.bracket;
            const styles = state.info.bracket_styles || {};
            
            if (!bracket || !bracket.upper) { 
                mainContainer.innerHTML = `<div class="w-full text-center col-span-12"><h1 class="text-4xl bracket-title">Waiting for tournament...</h1></div>`; 
                return; 
            }
            
            let upperBracketHtml = renderBracket('upper', bracket.upper, styles, state);
            let lowerBracketHtml = renderBracket('lower', bracket.lower, styles, state);
            let finalBracketHtml = bracket.grand_final ? renderGrandFinal(bracket.grand_final, styles, state) : '';

            mainContainer.innerHTML = `
                <canvas id="connector-canvas"></canvas>
                <div class="flex flex-col gap-6 z-10 flex-grow">
                    <div id="upper-bracket-container">${upperBracketHtml}</div>
                    <div id="lower-bracket-container">${lowerBracketHtml}</div>
                </div>
                <div id="grand-final-container" class="absolute top-1/2 -translate-y-1/2 right-8 z-10">${finalBracketHtml}</div>
            `;
            
            setTimeout(drawConnectors, 100);
        }

        function renderBracket(type, bracketData, styles, state) {
            if (!bracketData || !bracketData.rounds) return '';
            
            const style = styles[type] || {};
            const title = style.title || `${type.toUpperCase()} BRACKET`;
            const color = style.color || '#FFFFFF';
            
            let roundsHtml = bracketData.rounds.map((round) => {
                let matchesHtml = round.matches.map(match => createStreamMatchElement(match, state).outerHTML).join('');
                return `
                    <div class="round-column flex flex-col justify-around items-center space-y-3 h-full">
                        <h3 class="text-lg round-title text-gray-400">${round.name}</h3>
                        ${matchesHtml}
                    </div>
                `;
            }).join('');

            return `
                <h2 class="text-2xl font-bold mb-3 bracket-title" style="color: ${color};">${title}</h2>
                <div class="flex-grow flex justify-start items-start gap-12 px-4">${roundsHtml}</div>
            `;
        }

        function renderGrandFinal(finalData, styles, state) {
            const match = finalData.matches[0];
            const style = styles.final || {};
            const title = style.title || 'GRAND FINAL';
            const color = style.color || '#FFFFFF';
            
            return `
                <div class="text-center">
                    <h2 class="text-2xl font-bold mb-3 bracket-title" style="color: ${color};">${title}</h2>
                    ${createStreamMatchElement(match, state).outerHTML}
                </div>
            `;
        }
        
        function createStreamMatchElement(match, state) {
            const matchEl = document.createElement('div');
            matchEl.className = `match-card rounded-md shadow-md p-1.5 w-56`;
            const winnerIds = match.winners.map(w => w.trackmania_id || w.trackmania_name || w.name);
            const playersHtml = match.players.map(player => {
                const displayName = player.display_bracket_name || player.trackmania_name || player.name || 'TBD';
                const isWinner = winnerIds.includes(player.trackmania_id || player.trackmania_name || player.name);
                return `<div class="player-row flex justify-between items-center p-1 rounded ${isWinner ? 'winner' : ''}"><div class="flex items-center truncate"><span class="text-xs font-semibold text-gray-300 w-6">${player.seed || ''}</span><span class="text-base font-bold truncate pr-2">${displayName}</span></div><span class="text-xl font-bold">${player.score}</span></div>`;
            }).join('');
            matchEl.innerHTML = `<div class="space-y-1">${playersHtml}</div>`;
            return matchEl;
        }

        function renderSwissView(state) {
            applyStreamStyles(state.info.colors);
            const bracket = state.bracket;
            let content = '';
            let previousResultsHtml = '';

            if (bracket.history && bracket.history[`round_${bracket.round - 1}`]) {
                const prevRoundMatches = bracket.history[`round_${bracket.round - 1}`];
                previousResultsHtml = `
                    <div class="mb-8">
                        <h2 class="text-3xl font-bold bracket-title text-center mb-4 text-gray-400">Results from Swiss Round ${bracket.round - 1}</h2>
                        <div class="grid grid-cols-4 gap-8">` +
                        prevRoundMatches.map(match => createSwissMatchCard(match, match.name || `Match ${match.id.slice(-1)}`, true)).join('') +
                        `</div>
                    </div>`;
            }

            const stageTitle = `Swiss Round ${bracket.round}`;
            content = previousResultsHtml + `<h1 class="text-5xl font-bold bracket-title text-center mb-8">${stageTitle}</h1>
            <div class="grid grid-cols-4 gap-8">` +
            bracket.matches.map(match => createSwissMatchCard(match, match.name || `Match ${match.id.slice(-1)}`)).join('') +
            `</div>`;
            
            mainContainer.innerHTML = content;
        }

        function createSwissMatchCard(match, title, isSeedingResult = false) {
            const playersHtml = match.players.sort((a, b) => b.score - a.score).map(p => {
                const displayName = p.display_bracket_name || p.trackmania_name || p.name || 'TBD';
                return `
                <div class="flex justify-between items-center text-2xl p-2 rounded ${isSeedingResult ? 'bg-gray-600' : 'bg-gray-700'}">
                    <span class="font-bold">${displayName}</span>
                    <span class="font-bold text-cyan-400">${p.score}</span>
                </div>`;
            }).join('<div class="my-2"></div>');
            return `<div class="bg-gray-800 p-4 rounded-xl"><h2 class="text-3xl font-bold text-center text-purple-400 mb-4">${title}</h2>${playersHtml}</div>`;
        }

        async function fetchData() {
            try {
                const response = await fetch('/api/status');
                const state = await response.json();
                renderBracketView(state);
            } catch (error) {
                console.error("Failed to fetch tournament status:", error);
            }
        }
        
        window.addEventListener('resize', drawConnectors);
        fetchData();
        setInterval(fetchData, 3000);
    </script>
</body>
</html>
